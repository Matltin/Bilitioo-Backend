// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ticket.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const getTicketDetails = `-- name: GetTicketDetails :one
SELECT 
    oc.province AS "origin",
    dc.province AS "destination",
    t.departure_time,
    t.arrival_time,
    t.amount,
    v.capacity,
    v.vehicle_type,
    v.feature,
    b."VIP",
    b.bed_chair,
    tr.rank,
    tr.have_compartment,
    a.flight_class,
    a.name AS airplane_name

FROM "ticket" t
INNER JOIN "vehicle" v ON t.vehicle_id = v.id
LEFT JOIN "bus" b ON b.vehicle_id = v.id 
LEFT JOIN "train" tr ON tr.vehicle_id = v.id 
LEFT JOIN "airplane" a ON a.vehicle_id = v.id 
INNER JOIN "route" ro ON t.route_id = ro.id
INNER JOIN "city" oc ON oc.id = ro.origin_city_id
INNER JOIN "city" dc ON dc.id = ro.destination_city_id
WHERE t.id = $1
`

type GetTicketDetailsRow struct {
	Origin          string          `json:"origin"`
	Destination     string          `json:"destination"`
	DepartureTime   time.Time       `json:"departure_time"`
	ArrivalTime     time.Time       `json:"arrival_time"`
	Amount          int64           `json:"amount"`
	Capacity        int32           `json:"capacity"`
	VehicleType     VehicleType     `json:"vehicle_type"`
	Feature         json.RawMessage `json:"feature"`
	VIP             sql.NullBool    `json:"VIP"`
	BedChair        sql.NullBool    `json:"bed_chair"`
	Rank            sql.NullInt32   `json:"rank"`
	HaveCompartment sql.NullBool    `json:"have_compartment"`
	FlightClass     NullFlightClass `json:"flight_class"`
	AirplaneName    sql.NullString  `json:"airplane_name"`
}

func (q *Queries) GetTicketDetails(ctx context.Context, id int64) (GetTicketDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getTicketDetails, id)
	var i GetTicketDetailsRow
	err := row.Scan(
		&i.Origin,
		&i.Destination,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.Amount,
		&i.Capacity,
		&i.VehicleType,
		&i.Feature,
		&i.VIP,
		&i.BedChair,
		&i.Rank,
		&i.HaveCompartment,
		&i.FlightClass,
		&i.AirplaneName,
	)
	return i, err
}

const searchTickets = `-- name: SearchTickets :many
SELECT 
    t.id,
    t.vehicle_id,
    t.seat_id,
    t.vehicle_type,
    t.route_id,
    t.amount,
    t.departure_time,
    t.arrival_time,
    t.count_stand,
    t.status
FROM ticket t
JOIN route r ON t.route_id = r.id
WHERE
    ($1::bigint IS NULL OR r.origin_city_id = $1)
    AND ($2::bigint IS NULL OR r.destination_city_id = $2)
    AND ($3::date IS NULL OR t.departure_time::date = $3)
    AND ($4::vehicle_type IS NULL OR t.vehicle_type = $4)
    AND t.status = 'NOT_RESERVED'
ORDER BY t.departure_time ASC
LIMIT 50
`

type SearchTicketsParams struct {
	Column1 int64       `json:"column_1"`
	Column2 int64       `json:"column_2"`
	Column3 time.Time   `json:"column_3"`
	Column4 VehicleType `json:"column_4"`
}

type SearchTicketsRow struct {
	ID            int64                        `json:"id"`
	VehicleID     int64                        `json:"vehicle_id"`
	SeatID        int64                        `json:"seat_id"`
	VehicleType   VehicleType                  `json:"vehicle_type"`
	RouteID       int64                        `json:"route_id"`
	Amount        int64                        `json:"amount"`
	DepartureTime time.Time                    `json:"departure_time"`
	ArrivalTime   time.Time                    `json:"arrival_time"`
	CountStand    int32                        `json:"count_stand"`
	Status        CheckReservationTicketStatus `json:"status"`
}

func (q *Queries) SearchTickets(ctx context.Context, arg SearchTicketsParams) ([]SearchTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTickets,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchTicketsRow{}
	for rows.Next() {
		var i SearchTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.SeatID,
			&i.VehicleType,
			&i.RouteID,
			&i.Amount,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.CountStand,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
