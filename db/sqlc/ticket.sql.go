// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ticket.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const getAllTickets = `-- name: GetAllTickets :many
SELECT 
      t.id, t.vehicle_id, t.seat_id, t.vehicle_type, t.route_id, t.amount, t.departure_time, t.arrival_time, t.count_stand, t.status, t.created_at, 
      ro.origin_city_id AS origin_province_id,
      ro.destination_city_id AS destination_province_id
FROM "ticket" t
INNER JOIN "route" ro ON t.route_id = ro.id
WHERE status != 'RESERVED'
`

type GetAllTicketsRow struct {
	ID                    int64                        `json:"id"`
	VehicleID             int64                        `json:"vehicle_id"`
	SeatID                int64                        `json:"seat_id"`
	VehicleType           VehicleType                  `json:"vehicle_type"`
	RouteID               int64                        `json:"route_id"`
	Amount                int64                        `json:"amount"`
	DepartureTime         time.Time                    `json:"departure_time"`
	ArrivalTime           time.Time                    `json:"arrival_time"`
	CountStand            int32                        `json:"count_stand"`
	Status                CheckReservationTicketStatus `json:"status"`
	CreatedAt             time.Time                    `json:"created_at"`
	OriginProvinceID      int64                        `json:"origin_province_id"`
	DestinationProvinceID int64                        `json:"destination_province_id"`
}

func (q *Queries) GetAllTickets(ctx context.Context) ([]GetAllTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTickets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTicketsRow{}
	for rows.Next() {
		var i GetAllTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.SeatID,
			&i.VehicleType,
			&i.RouteID,
			&i.Amount,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.CountStand,
			&i.Status,
			&i.CreatedAt,
			&i.OriginProvinceID,
			&i.DestinationProvinceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserCompletedTickets = `-- name: GetAllUserCompletedTickets :many
SELECT 
t.id,
  oc.province,
  dc.province,
  re.status,
  p.status
FROM "reservation" re 
INNER JOIN "payment" p ON p.id = re.payment_id
INNER JOIN "ticket" t ON re.ticket_id = t.id
INNER JOIN "route" ro ON t.route_id = ro.id
INNER JOIN "city" oc ON oc.id = ro.origin_city_id
INNER JOIN "city" dc ON dc.id = ro.destination_city_id
WHERE p.status = 'COMPLETED' AND re.user_id = $1
`

type GetAllUserCompletedTicketsRow struct {
	ID         int64         `json:"id"`
	Province   string        `json:"province"`
	Province_2 string        `json:"province_2"`
	Status     TicketStatus  `json:"status"`
	Status_2   PaymentStatus `json:"status_2"`
}

func (q *Queries) GetAllUserCompletedTickets(ctx context.Context, userID int64) ([]GetAllUserCompletedTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserCompletedTickets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUserCompletedTicketsRow{}
	for rows.Next() {
		var i GetAllUserCompletedTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Province,
			&i.Province_2,
			&i.Status,
			&i.Status_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserNotCompletedTickets = `-- name: GetAllUserNotCompletedTickets :many
SELECT 
t.id,
  oc.province,
  dc.province,
  re.status,
  p.status
FROM "reservation" re 
INNER JOIN "payment" p ON p.id = re.payment_id
INNER JOIN "ticket" t ON re.ticket_id = t.id
INNER JOIN "route" ro ON t.route_id = ro.id
INNER JOIN "city" oc ON oc.id = ro.origin_city_id
INNER JOIN "city" dc ON dc.id = ro.destination_city_id
WHERE p.status != 'COMPLETED' AND re.user_id = $1
`

type GetAllUserNotCompletedTicketsRow struct {
	ID         int64         `json:"id"`
	Province   string        `json:"province"`
	Province_2 string        `json:"province_2"`
	Status     TicketStatus  `json:"status"`
	Status_2   PaymentStatus `json:"status_2"`
}

func (q *Queries) GetAllUserNotCompletedTickets(ctx context.Context, userID int64) ([]GetAllUserNotCompletedTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserNotCompletedTickets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUserNotCompletedTicketsRow{}
	for rows.Next() {
		var i GetAllUserNotCompletedTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Province,
			&i.Province_2,
			&i.Status,
			&i.Status_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicket = `-- name: GetTicket :one
SELECT id, vehicle_id, seat_id, vehicle_type, route_id, amount, departure_time, arrival_time, count_stand, status, created_at FROM "ticket"
WHERE id = $1
`

func (q *Queries) GetTicket(ctx context.Context, id int64) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, getTicket, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.SeatID,
		&i.VehicleType,
		&i.RouteID,
		&i.Amount,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.CountStand,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getTicketDetails = `-- name: GetTicketDetails :one
SELECT 
    oc.province AS "origin",
    dc.province AS "destination",
    t.departure_time,
    t.arrival_time,
    t.amount,
    v.capacity,
    v.vehicle_type,
    v.feature,
    b."VIP",
    t.status,
    b.bed_chair,
    tr.rank,
    tr.have_compartment,
    a.flight_class,
    a.name AS airplane_name

FROM "ticket" t
INNER JOIN "vehicle" v ON t.vehicle_id = v.id
LEFT JOIN "bus" b ON b.vehicle_id = v.id 
LEFT JOIN "train" tr ON tr.vehicle_id = v.id 
LEFT JOIN "airplane" a ON a.vehicle_id = v.id 
INNER JOIN "route" ro ON t.route_id = ro.id
INNER JOIN "city" oc ON oc.id = ro.origin_city_id
INNER JOIN "city" dc ON dc.id = ro.destination_city_id
WHERE t.id = $1
`

type GetTicketDetailsRow struct {
	Origin          string                       `json:"origin"`
	Destination     string                       `json:"destination"`
	DepartureTime   time.Time                    `json:"departure_time"`
	ArrivalTime     time.Time                    `json:"arrival_time"`
	Amount          int64                        `json:"amount"`
	Capacity        int32                        `json:"capacity"`
	VehicleType     VehicleType                  `json:"vehicle_type"`
	Feature         json.RawMessage              `json:"feature"`
	VIP             sql.NullBool                 `json:"VIP"`
	Status          CheckReservationTicketStatus `json:"status"`
	BedChair        sql.NullBool                 `json:"bed_chair"`
	Rank            sql.NullInt32                `json:"rank"`
	HaveCompartment sql.NullBool                 `json:"have_compartment"`
	FlightClass     NullFlightClass              `json:"flight_class"`
	AirplaneName    sql.NullString               `json:"airplane_name"`
}

func (q *Queries) GetTicketDetails(ctx context.Context, id int64) (GetTicketDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getTicketDetails, id)
	var i GetTicketDetailsRow
	err := row.Scan(
		&i.Origin,
		&i.Destination,
		&i.DepartureTime,
		&i.ArrivalTime,
		&i.Amount,
		&i.Capacity,
		&i.VehicleType,
		&i.Feature,
		&i.VIP,
		&i.Status,
		&i.BedChair,
		&i.Rank,
		&i.HaveCompartment,
		&i.FlightClass,
		&i.AirplaneName,
	)
	return i, err
}

const searchTickets = `-- name: SearchTickets :many

SELECT 
  t.id, t.vehicle_id, t.seat_id, t.vehicle_type, t.route_id, 
  t.amount, t.departure_time, t.arrival_time, t.count_stand, 
  t.status, t.created_at,
  r.origin_city_id, r.destination_city_id,
  v.capacity, v.feature,
  c.name as company_name,
  orig_city.province as origin_province,
  orig_city.county as origin_county,
  dest_city.province as destination_province,
  dest_city.county as destination_county
FROM ticket t
JOIN route r ON t.route_id = r.id
JOIN vehicle v ON t.vehicle_id = v.id
JOIN company c ON v.company_id = c.id
JOIN city orig_city ON r.origin_city_id = orig_city.id
JOIN city dest_city ON r.destination_city_id = dest_city.id
WHERE r.origin_city_id = $1
  AND r.destination_city_id = $2
  AND t.departure_time >= $3
  AND t.departure_time < $4
  AND t.vehicle_type = $5::vehicle_type
  AND t.status = 'NOT_RESERVED'
ORDER BY t.departure_time
`

type SearchTicketsParams struct {
	OriginCityID      int64       `json:"origin_city_id"`
	DestinationCityID int64       `json:"destination_city_id"`
	DepartureTime     time.Time   `json:"departure_time"`
	DepartureTime_2   time.Time   `json:"departure_time_2"`
	Column5           VehicleType `json:"column_5"`
}

type SearchTicketsRow struct {
	ID                  int64                        `json:"id"`
	VehicleID           int64                        `json:"vehicle_id"`
	SeatID              int64                        `json:"seat_id"`
	VehicleType         VehicleType                  `json:"vehicle_type"`
	RouteID             int64                        `json:"route_id"`
	Amount              int64                        `json:"amount"`
	DepartureTime       time.Time                    `json:"departure_time"`
	ArrivalTime         time.Time                    `json:"arrival_time"`
	CountStand          int32                        `json:"count_stand"`
	Status              CheckReservationTicketStatus `json:"status"`
	CreatedAt           time.Time                    `json:"created_at"`
	OriginCityID        int64                        `json:"origin_city_id"`
	DestinationCityID   int64                        `json:"destination_city_id"`
	Capacity            int32                        `json:"capacity"`
	Feature             json.RawMessage              `json:"feature"`
	CompanyName         string                       `json:"company_name"`
	OriginProvince      string                       `json:"origin_province"`
	OriginCounty        string                       `json:"origin_county"`
	DestinationProvince string                       `json:"destination_province"`
	DestinationCounty   string                       `json:"destination_county"`
}

// SELECT
//
//	t.id,
//	t.vehicle_id,
//	t.seat_id,
//	t.vehicle_type,
//	t.route_id,
//	t.amount,
//	to_char(t.departure_time, 'YYYY-MM-DD HH24:MI') as departure_time,
//	to_char(t.arrival_time, 'YYYY-MM-DD HH24:MI') as arrival_time,
//	t.count_stand,
//	t.status
//
// FROM ticket t
// JOIN route r ON t.route_id = r.id
// WHERE
//
//	($1::bigint IS NULL OR r.origin_city_id = $1)
//	AND ($2::bigint IS NULL OR r.destination_city_id = $2)
//	AND ($3::date IS NULL OR t.departure_time::date = $3::date)
//	AND ($4::vehicle_type IS NULL OR t.vehicle_type = $4)
//	AND t.status = 'NOT_RESERVED'
//
// ORDER BY t.departure_time ASC
// LIMIT 50;
func (q *Queries) SearchTickets(ctx context.Context, arg SearchTicketsParams) ([]SearchTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTickets,
		arg.OriginCityID,
		arg.DestinationCityID,
		arg.DepartureTime,
		arg.DepartureTime_2,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchTicketsRow{}
	for rows.Next() {
		var i SearchTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.SeatID,
			&i.VehicleType,
			&i.RouteID,
			&i.Amount,
			&i.DepartureTime,
			&i.ArrivalTime,
			&i.CountStand,
			&i.Status,
			&i.CreatedAt,
			&i.OriginCityID,
			&i.DestinationCityID,
			&i.Capacity,
			&i.Feature,
			&i.CompanyName,
			&i.OriginProvince,
			&i.OriginCounty,
			&i.DestinationProvince,
			&i.DestinationCounty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE "ticket"
SET status = $1
WHERE id = $2
RETURNING amount
`

type UpdateTicketStatusParams struct {
	Status CheckReservationTicketStatus `json:"status"`
	ID     int64                        `json:"id"`
}

func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatus, arg.Status, arg.ID)
	var amount int64
	err := row.Scan(&amount)
	return amount, err
}